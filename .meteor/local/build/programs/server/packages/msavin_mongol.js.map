{"version":3,"sources":["msavin:mongol/common/common.js","msavin:mongol/server/methods.js","msavin:mongol/server/utility_functions.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAAA,2B;;AAEA,kD;AACA,sE;AACA,qG;AACA,oC;AACA,+G;AACA,wD;;AAEA,c;;AAEA,C;;AAEA,2E;;AAEA,+C;;AAEA,6C;AACA,iE;AACA,uC;;AAEA,oH;AACA,sC;AACA,8D;;AAEA,gJ;AACA,wF;AACA,iI;;AAEA,U;AACA,wE;AACA,kH;;;AAGA,0D;;AAEA,+B;;AAEA,yD;;AAEA,G;AACA,E;AACA,E;;;;;;;;;;;;;;;;;;;AC1CA,gB;AACA,8B;;AAEA,uC;AACA,oC;;AAEA,wC;AACA,0C;;AAEA,wC;AACA,wB;AACA,K;AACA,iB;;AAEA,oD;AACA,c;;AAEA,8D;AACA,oC;AACA,gB;AACA,gB;AACA,kC;AACA,U;AACA,U;;AAEA,I;AACA,gF;;AAEA,kC;AACA,gC;AACA,wC;;AAEA,6D;AACA,oC;;AAEA,iD;AACA,qB;AACA,O;;AAEA,wB;AACA,qD;AACA,0B;AACA,8D;AACA,U;AACA,E;;AAEA,4B;AACA,oC;;AAEA,wG;AACA,C;AACA,8H;AACA,M;AACA,mE;AACA,8E;AACA,mH;AACA,G;AACA,4B;AACA,uB;AACA,+B;AACA,sB;AACA,2B;AACA,kC;AACA,uB;AACA,S;AACA,a;AACA,K;;AAEA,oB;AACA,6B;AACA,uB;AACA,Q;AACA,yB;AACA,M;;AAEA,I;AACA,wD;;AAEA,kC;AACA,8B;;AAEA,6D;;AAEA,wC;;AAEA,I;AACA,2D;;AAEA,kC;AACA,8B;;AAEA,6D;AACA,yD;;AAEA,2B;;AAEA,2D;;AAEA,uB;;AAEA,I;AACA,yD;;AAEA,kC;AACA,gC;;AAEA,6D;;AAEA,8H;AACA,mE;AACA,6C;AACA,sB;AACA,2B;AACA,kC;AACA,uB;AACA,S;AACA,a;AACA,K;;AAEA,0C;;AAEA,I;AACA,G;;;;;;;;;;;;;;;;;;;AC1HA,sD;;AAEA,4E;AACA,qE;AACA,mD;;AAEA,kF;AACA,wF;AACA,8F;AACA,wD;AACA,0G;AACA,wF;AACA,6D;AACA,8F;;AAEA,iC;AACA,uD;AACA,oE;;;AAGA,8D;;AAEA,yD;AACA,kE;;AAEA,qB;;AAEA,kC;AACA,oC;AACA,uK;;AAEA,0G;;AAEA,wE;;AAEA,iG;;AAEA,0H;;AAEA,oH;;AAEA,4D;;AAEA,2C;;AAEA,oD;;AAEA,uE;AACA,0G;AACA,a;;AAEA,K;;AAEA,+C;;AAEA,uE;AACA,2B;AACA,qE;AACA,wG;AACA,O;AACA,4C;AACA,sC;AACA,a;;AAEA,K;;AAEA,sC;;AAEA,0D;AACA,yE;AACA,qD;AACA,8F;AACA,+D;AACA,iH;AACA,8B;;AAEA,K;;AAEA,mB;;AAEA,E;;AAEA,wC;;AAEA,6B;;AAEA,yB;AACA,64C;;AAEA,4G;AACA,mL;AACA,iE;;AAEA,2D;AACA,+B;AACA,6E;AACA,kC;AACA,wD;AACA,0I;AACA,8F;;AAEA,iB;;AAEA,kF;;AAEA,K","file":"/packages/msavin:mongol.js","sourcesContent":["if (Mongol === undefined) {\n\n  // Reserve this variable name across the package\n  // In case we'd like to export it to give package users a simple api\n  // e.g. when all collections have been matched by default, but the developer wants to suppress some\n  // Mongol.hideCollection('posts');\n  // Downside is that it pollutes the global namespace with `Mongol`, but most apps can probably live with that\n  // See /client/defaults/defaults.js for implementation\n\n  Mongol = {};\n\n}\n\n// Go through a variety of means of trying to return the correct collection\n\nMongol.Collection = function (collectionName) {\n\n  return Mongo.Collection.get(collectionName)\n    // This should automatically match all collections by default\n    // including namespaced collections\n\n  || ((Meteor.isServer) ? eval(collectionName) : Meteor._get.apply(null,[window].concat(collectionName.split('.'))))\n  // For user defined collection names\n  // in the form of Meteor's Mongo.Collection names as strings\n\n  || ((Meteor.isServer) ? eval(firstToUpper(collectionName)) : Meteor._get.apply(null,[window].concat(firstToUpper(collectionName).split('.'))))\n  // For user defined collections where the user has typical upper-case collection names\n  // but they've put actual mongodb collection names into the Mongol config instead of Meteor's Mongo.Collection names as strings\n\n  || null;\n  // If the user has gone for unconventional casing of collection names,\n  // they'll have to get them right (i.e. Meteor's Mongo.Collection names as string) in the Mongol config manually\n\n\n  // Changes the first character of a string to upper case\n\n  function firstToUpper(text) {\n\n    return text.charAt(0).toUpperCase() + text.substr(1);\n\n  }\n  \n};\n","Meteor.methods({\n  Mongol_verify: function () {\n\n    // Check if the Meteor absolute URL\n    // begins with http://localhost:\n\n    var location = Meteor.absoluteUrl(),\n      current = location.substring(0, 17);\n\n    if (current = \"http://localhost:\") {\n      return \"verified\";\n    }\n    return false;\n\n    // Currently not in use, but under consideration\n    // To Use:\n\n    // Meteor.call(\"Mongol_verify\", function (error, result) {\n    // \tif (result === \"verified\") {\n    // \t\ttask();\n    // \t} else {\n    // \t\treturn \"absoluteURLError\"\n    // \t};\n    // });\n\n  },\n  Mongol_update: function (collectionName, documentData, originalDocumentData) {\n\n    check(collectionName, String);\n    check(documentData, Object);\n    check(originalDocumentData, Object);\n\n    var MongolCollection = Mongol.Collection(collectionName),\n      documentID = documentData._id;\n\n    var currentDbDoc = MongolCollection.findOne({\n      _id: documentID\n    });\n\n    if (!currentDbDoc) {\n\t  // A document with this _id value is not in the db\n\t  // Do an insert instead\n\t  Meteor.call(\"Mongol_insert\", collectionName, documentData);\n\t  return;\n\t}\n\n    delete documentData._id;\n    delete originalDocumentData._id;\n\n    var updatedDocumentData = Mongol.diffDocumentData(currentDbDoc, documentData, originalDocumentData);\n\t\n    if (!!Package['aldeed:simple-schema'] && !!Package['aldeed:collection2'] && _.isFunction(MongolCollection.simpleSchema)) {\n      \n      // This is to nullify the effects of SimpleSchema/Collection2\n      // Using `upsert` means that a user can change the _id value in the JSON\n      // and then press the 'Update' button to create a duplicate (published keys/values only) with a different _id\n\t  \n\t  MongolCollection.update({\n        _id: documentID\n      }, updatedDocumentData, {\n        filter: false,\n        autoConvert: false,\n        removeEmptyStrings: false,\n        validate: false\n      });\n      return;\n    }\n\n    // Run the magic\n    MongolCollection.update({\n        _id: documentID\n      },\n      updatedDocumentData\n    );\n\n  },\n  Mongol_remove: function (collectionName, documentID) {\n\n    check(collectionName, String);\n    check(documentID, String);\n\n    var MongolCollection = Mongol.Collection(collectionName);\n\n    MongolCollection.remove(documentID);\n\n  },\n  Mongol_duplicate: function (collectionName, documentID) {\n\n    check(collectionName, String);\n    check(documentID, String);\n\n    var MongolCollection = Mongol.Collection(collectionName),\n      OriginalDoc = MongolCollection.findOne(documentID);\n\n    delete OriginalDoc._id;\n\n    var NewDocument = MongolCollection.insert(OriginalDoc);\n\n    return NewDocument;\n\n  },\n  Mongol_insert: function(collectionName, documentData) {\n\n    check(collectionName, String);\n    check(documentData, Object);\n\n    var MongolCollection = Mongol.Collection(collectionName);\n\n    if (!!Package['aldeed:simple-schema'] && !!Package['aldeed:collection2'] && _.isFunction(MongolCollection.simpleSchema)) {\n      // This is to nullify the effects of SimpleSchema/Collection2\n      MongolCollection.insert(documentData, {\n        filter: false,\n        autoConvert: false,\n        removeEmptyStrings: false,\n        validate: false\n      });\n      return;\n    }\n\n    MongolCollection.insert(documentData);\n\n  },\n});\n","// This function takes three data points into account:\n\n// 1) the actual document as it stands on the server, prior to being updated\n// 2) the oldData that was on the client before the user pressed save\n// 3) the newData that the client is trying to save\n\n// This function decides which fields it is going to make writes to on this basis:\n// 1) The field(s) being overwritten must appear in the db doc and on the client oldData\n//    (if they only appear in the oldData these must have been added dynamically on the client\n//     and we don't want to save these fields to the db)\n//    -- this includes fields that are being removed (i.e. they must appear in the db doc and the oldData)\n// 2) Only fields that appear in the newData, but not the oldData or db doc can be added\n//    (if it appears in the db doc, throw an error that says:\n//     \"There is an unpublished field in the database with that name. Update cannot be made.\")\n\n// The ramifications of all this:\n// You can only update/remove fields that are published\n// You can only add new fields if they don't exist in the db already\n\n\nMongol.diffDocumentData = function (dbDoc, newData, oldData) {\n\n  // TODO -- recurse into subdocuments, performing checks\n  // using the Meteor._get function (as seen in /common/common.js)\n\n  var finalData = {};\n\n  var dbDocFields = _.keys(dbDoc),\n    newDataFields = _.keys(newData),\n    oldDataFields = _.keys(oldData); // console.log(\"dbDocFields\",dbDocFields); console.log(\"newDataFields\",newDataFields); console.log(\"oldDataFields\",oldDataFields);\n\n  // First get the set of fields that we won't be saving because they were dynamically added on the client\n\n  var dynamicallyAddedFields = _.difference(oldDataFields, dbDocFields);\n\n  // The get the fields that must retain their dbDoc field value, because they we'ren't published\n\n  var unpublishedFields = _.difference(dbDocFields, oldDataFields); // console.log(\"unpublishedFields\",unpublishedFields);\n\n  // iterate over all fields, old and new, and ascertain the field value that must be added to the final data object\n\n  var oldAndNewFields = _.union(dbDocFields, newDataFields);\n\n  _.each(oldAndNewFields, function(field) {\n\n    if (_.contains(dynamicallyAddedFields, field)) {\n\n      // We don't want to add this field to the actual mongodb document\n      console.log(\"'\" + field + \"' appears to be a dynamically added field. This field was not updated.\");\n      return;\n\n    }\n\n    if (_.contains(unpublishedFields, field)) {\n\n      // We don't want to overwrite the existing mondodb document value\n      if (newData[field]) {\n        // Give a message to user as to why that field wasn't updated\n        console.log(\"'\" + field + \"' is an unpublished field. This field's value was not overwritten.\");\n      }\n      // Make sure the old value is retained\n      finalData[field] = dbDoc[field];\n      return;\n\n    }\n\n    finalData[field] = newData[field];\n\n    // This will let unpublished fields into the database,\n    // so the user may be confused by the lack of an update in the client\n    // simply because the added field isn't published\n    // The following solves that problem, but doesn't allow new fields to be published at all:\n    //     finalData[field] = oldData[field] && newData[field];\n    // We actually need to know the set of fields published by the publication that the client side doc came from\n    // but how do we get that?\n\n  });\n\n  return finalData;\n\n};\n\n// Test code for Mongol.diffDocumentData\n\n/*Meteor.startup(function() {\n\n  // Take a user document\n  var sampleDbDoc = { \"_id\" : \"exampleuser1\", \"createdAt\" : 1375253926213, \"defaultPrograms\" : { \"514d75dc97d9562095578800\" : \"MYP\", \"515be9e6a57068c708000000\" : \"PYP\" }, \"department_id\" : [  \"GMsv9YzaCuL6dFBYL\" ], \"emails\" : [  {  \"address\" : \"babrahams@wab.edu\",  \"verified\" : true } ], \"myCourses\" : [  \"QqofG3XyEtQPgFb72\",  \"fvTxhAyfMxFbhzwK7\",  \"jcPtgwN2t6pTMQDEp\" ], \"organization_id\" : [  \"51f76bcb45623dfb1e0d3100\" ], \"permContexts\" : [ \t{ \t\"department_id\" : \"GMsv9YzaCuL6dFBYL\", \"perms\" : [ \t\"editRoles\", \t\"editCourses\", \t\"editUnits\", \t\"editAssessments\", \t\"editDepartments\" ] } ], \"roleContexts\" : [ \t{ \t\"organization_id\" : \"51f76bcb45623dfb1e0d3100\", \t\"school_id\" : \"514d75dc97d9562095578800\", \t\"department_id\" : \"GMsv9YzaCuL6dFBYL\", \t\"roles\" : [ \t\"iQD4BhnB8PFWwHCcg\" ] }, \t{ \t\"organization_id\" : \"2BjJbMyRLWa4iofQm\" } ], \"school_id\" : [  \"514d75dc97d9562095578800\" ], \"services\" : { \"password\" : { \"bcrypt\" : \"$2a$10$M55xiZA6rX0EwZ6xBk3Rre6/J5s3XUunre5.5ijyU3.ilpYZQFmtO\" }, \"resume\" : { \"loginTokens\" : [ \t{ \t\"when\" : \"2014-12-24T12:00:06.725Z\", \t\"hashedToken\" : \"not/telling=\" }, \t{ \t\"when\" : \"2015-01-16T04:45:10.574Z\", \t\"hashedToken\" : \"bigbadhashedtoken=\" }, \t{ \t\"when\" : \"2015-01-22T02:01:57.671Z\", \t\"hashedToken\" : \"9HSCRUygOiPYgmUsmWA5jcYutqKnjT9OByHPA6LbBB8=\" } ] } }, \"superuser\" : [  \"51f76bcb45623dfb1e0d3100\",  \"2BjJbMyRLWa4iofQm\",  \"ZkeRkDEEcp72bAFQY\" ], \"transaction_id\" : \"shQ9fzcZYSgLLnptC\" };\n\n  // Simulate the oldData getting sent back from the client (the fields should be a subset of the db fields)\n  var sampleOldData = _.extend(_.clone(sampleDbDoc),{dynamicallyAddedField:true, secondDynamicallyAddedField: \"Dynamically added value\"}); // Simulate two dynamically added fields\n  delete sampleOldData.services; // Simulate an unpublished field\n\n  // Simulate the newData getting sent back from the client\n  // e.g. user adds a new field\n  var sampleNewData = _.extend(_.clone(sampleOldData),{brandNewField: true});\n  // brandNewField should be added\n  delete sampleNewData.createdAt; // This should be gone\n  sampleNewData.secondDynamicallyAddedField = \"Dynamically added value overwritten by user\"; // seconddynamicallyAddedField should be gone\n  sampleNewData.transaction_id = \"overwritten transaction id\"; // This field should be changed\n\n  // Run the test\n\n  console.log(Mongol.diffDocumentData(sampleDbDoc, sampleNewData, sampleOldData));\n\n});*/\n"]}